闭包详解

闭包应用的两种情况：函数作为返回值，函数作为参数传递

一、函数作为返回值

function fn() {
	var max=10;

	return function bar(x) {
		if (x>max) {
			console.log(x);
		}
	}
}

var f1=fn();
f1(15);

bar作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。

二、函数作为参数被传递

var max=10,
	fn=function (x) {
		if (x>max){
			console.log(x);
		}
	};

(function (f) {
	var max =100;
	f(15);
})(fn);

fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。

解释

---全局作用域start---

	---fn作用域start---
	function fn() {
		var max=10;

		---bar作用域start---
		return function bar(x) {
			if (x>max) {
				console.log(x);
			}
		}
		---bar作用域end---
	}
	---fn作用域end---

var f1=fn()，
	max=100;
f1(15);

---全局作用域end---


第一步：代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值，此时全局上下文环境是活动状态。max：undefined
第二步：执行第50行代码f1=fn()时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。全局上下文环境max：undefined，fn()上下文环境max：10
第三步：执行完第50行，fn()调用完成，按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。因为执行fn()时，返回的是一个函数。函数的特别之处
		在于可以创建一个独立的作用域。而正巧的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此这个max不能
		被销毁，销毁了之后bar函数中的max就找不到值了。
		因此，这里的fn()上下文环境不能被销毁，还依然存在于执行上下文栈中。
		--即执行到51行（max=100）时，全局上下文将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，全局上下文环境中的max被赋值为100.
第四步：执行到底52行（f1(15)）时，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。

执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10.
创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境海存在于栈中，因为bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。
所以，使用闭包会增加内容开销。		